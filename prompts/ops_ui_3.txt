Generate a configuration JSON with the following structure and rules:

{
  "intId": 9090,
  "configMap": {
    "RealTimeTransform": {
      "channelFieldTransformations": [
                                                     {
                                                         "Attribute": "abc",
                                                         "Transform Type": "CASE_CHANGE",
                                                         "Transform Name": "LOWER"
                                                     },
                                                     {
                                                         "Attribute": "abc",
                                                         "Transform Type": "HASHING",
                                                         "Transform Name": "MD2"
                                                     }
                                                 ],
      "requestTemplate": {}
    },
    "RealTimeUpload": {
      "uploadType": "API",
      "uploadFormat": {
        "apiDetails": {
          "uploadUrl": "",
          "apiType": "POST",
          "headers": {
            "Auth": "${bearerToken}"
          },
          "params" : {

          }
        },
        "requestBody": {
          "requestBody": {},
          "requestBodyType": "JSON"
        },
        "authDetails": {
          "authType": "Basic",
          "authData": {
            "username": "${clientId}",
            "password": "${eventId}"
          }
        }
      }
    }
  },
  "steps": {
    "RealTimeUpload": ["RealTimeTransform", "RealTimeUpload"]
  },
  "actionId": 421
}


Requirements:
Static Fields
"intId" ( but if you find intPartnerId somewhere use that as intId not static ), "actionId" ( if you find actionId somewhere use that not static ) , and "steps" must always retain their values as shown.

The full structure under "RealTimeUpload" is mostly fixed in shape.

RealTimeTransform Rules
"requestTemplate" remains an empty object: {}.

"channelFieldTransformations" is to be generated dynamically from the attributes present in the request body of the channel api information, you have to figure out what transformation that attribute need.

For each attribute that requires transformation:

Use the full path (e.g., "attributes.email").

The value should be a list of transformation objects:

[
  {
    "Attribute" : "path.to.attribute which have premitive datatype" // in the path, don't add [], or index
    "Transform Type": "HASHING",
    "Transform Name": "SHA256" | "MD5" | "MD6"
  }
]

You must determine which fields require transformation (e.g., PII like email, phone).

RealTimeUpload Rules
"uploadType" is JSON always, under requestBody, requestBody will be empty object always .

In "apiDetails" object:
uploadUrl : find it from channel informations and replace it in the above template, if you find any value which need to take form user, keep it like ${keyNameCammelCase}
apiType : find it from channel informations and replace it in the above template,
headers : find it from channel informations and replace it in the above template ( all keys and values find from channel information, the above config json is just a template)
params : find it from channel informations and replace it in the above template, ( all keys and values find from channel information, the above config json is just a template)

Any dynamic value (which should provide by user) that must be provided by the user should be represented using ${keyNameInCamelCase} format (e.g., ${bearerToken}).

In "headers":
List all key-value pairs required by the API from information.
If a value is fixed, include it directly. If it must come from the user, use the ${} placeholder.

In "authDetails":
Determine whether the API uses:
"authType": "Basic" (username/password), or
"authType": "API" (only if we have to hit some another api to fetch token ).
if nothing was there don't add authDetails objects in the final config json.

Set values as ${keyNameInCamelCase} for user-supplied values.

Return only the generated JSON config based on the above structure and logic.
